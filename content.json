{"meta":{"title":"BLOG","subtitle":"附标题","description":"描写","author":"achengacheng","url":"http://achengacheng.github.io"},"pages":[{"title":"Home","date":"2018-05-25T03:22:38.000Z","updated":"2019-02-10T07:35:23.055Z","comments":true,"path":"Home/index.html","permalink":"http://achengacheng.github.io/Home/index.html","excerpt":"","text":"这个人很懒，home什么都没留下"},{"title":"about","date":"2018-05-25T03:22:06.000Z","updated":"2019-02-10T07:36:44.589Z","comments":true,"path":"about/index.html","permalink":"http://achengacheng.github.io/about/index.html","excerpt":"","text":"这个人很懒，about 什么都没留下"},{"title":"categories","date":"2018-05-25T03:20:18.000Z","updated":"2019-02-10T07:36:30.419Z","comments":true,"path":"categories/index.html","permalink":"http://achengacheng.github.io/categories/index.html","excerpt":"","text":"这个人很懒，categories （分类）什么都没留下"},{"title":"tags","date":"2018-05-25T03:20:51.000Z","updated":"2019-02-10T07:41:14.769Z","comments":true,"path":"tags/index.html","permalink":"http://achengacheng.github.io/tags/index.html","excerpt":"","text":"这个人很懒tags什么都没留下"},{"title":"相册","date":"2018-05-25T03:20:51.000Z","updated":"2019-02-10T07:37:12.223Z","comments":true,"path":"相册/index.html","permalink":"http://achengacheng.github.io/相册/index.html","excerpt":"","text":"这个人很懒，相册 什么都没留下"}],"posts":[{"title":"hexo+github","slug":"180827","date":"2019-09-13T13:26:00.000Z","updated":"2019-09-13T13:44:46.070Z","comments":true,"path":"2019/09/13/180827/","link":"","permalink":"http://achengacheng.github.io/2019/09/13/180827/","excerpt":"","text":"判断一个对象是不是数组类型，4种方法: typeof 不行！只能区分原始类型和function 判断原型对象:obj.proto==Array.prototype问题: proto是隐藏属性，个别浏览器禁用解决: 父对象.isPrototypeOf(子对象) 判断构造函数:obj.constructor==Array问题: constructor可能禁止使用解决: obj instanceof Array问题: 不够严格:1). proto和constructor不止检查直接父级，且检查整个原型链。2). proto有可能被修改！ 判断隐藏的class属性class属性: 隐藏在每个对象内部，记录对象创建时的类型名。不随继承关系改变而改变。问题: class属性是内部隐藏属性，不能用.直接访问！解决: 只有顶级父类型Object.prototype中的toString()才可输出class属性值问题: 内置类型的prototype中都重写了新的toString()覆盖了顶级的toString()解决: 特殊的函数: .call()什么是: .call()可让任何一个对象，强行调用任何一个想调用的方法。何时: 想强行调用本来无法调用到的方法如何: 要调用的函数.call(对象) 在执行时，相当于: 对象.要调用的函数() ES5新API:var bool=Array.isArray(obj)强调: 其实采用的也是第三种方法call/apply/bind相同: 都可用于替换函数中不正确的this区别:1). call/apply:什么是:调用一个函数，并临时替换其中的this为指定对象何时: 在调用函数时，需要临时替换this为指定对象时如何:要调用的函数.call(对象,参数值,….) 调用函数 替换函数中的this为指定”对象” 传入参数如果参数值列表是一个数组:函数.apply(对象, 数组)2). bind什么是: 创建一个函数的副本，并永久替换其中的this为指定的对象何时: 如果函数，暂时不调用，而是仅创建副本，并永久替换this时","categories":[],"tags":[{"name":"题","slug":"题","permalink":"http://achengacheng.github.io/tags/题/"}]},{"title":"git","slug":"git","date":"2019-01-20T07:56:20.000Z","updated":"2019-07-13T11:14:46.943Z","comments":true,"path":"2019/01/20/git/","link":"","permalink":"http://achengacheng.github.io/2019/01/20/git/","excerpt":"","text":"如何将创建的工程同步到github上。第一步：创建工程之后，用终端进入工程。1cd /Users/hanwenguang/Desktop/pods/TestPreject 第二步：建立本地仓库1git init 第三步：将本地项目工作区的所有文件添加到暂存区1git add . 第四步：将暂存区的文件提交到本地仓库1git commit -m “注释&quot; 第五步： 在Github上创建自己的 New repository 名字注释自定义第六步：将本地仓库关联到Github上（后加上仓库地址：New repository后的地址）1git remote add origin 地址 第七步：将代码由本地仓库上传到Github远程仓库，刷新即可看到上传成功。12345//(不加这句可能报错出现错误的主要原因是github中的README.md文件不在本地代码目录中$ git pull --rebase origin master //可以通过该命令进行代码合并$ git push -u origin master//需要填写账号、密码时候，自己填写。通常一次通过之后就不需要了。 这样，上传文件存储和上传已有工程都已经成功。接下来下提交代码的命令：123456同步到服务器前先需要将服务器代码同步到本地命令：$ git pull如果执行失败，就按照提示还原有冲突的文件，然后再次尝试同步。命令：$ git checkout – &lt;有冲突的文件路径&gt;同步到服务器命令：$ git push origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://achengacheng.github.io/tags/git/"}]},{"title":"Vue面试题及答案","slug":"Vue面试题及答案","date":"2018-12-14T07:29:09.000Z","updated":"2019-02-20T08:19:24.629Z","comments":true,"path":"2018/12/14/Vue面试题及答案/","link":"","permalink":"http://achengacheng.github.io/2018/12/14/Vue面试题及答案/","excerpt":"","text":"整理面试题其实就是一次温故的过程，只是为了查漏补缺，看看自己那些方面还不懂，框架不用很容易忘记，为了经常方便温故自己整理一遍（都是一些基础的 vue 面试题，大神不用浪费时间往下看）（答案来自互联网，谨慎参考） 一、对于 MVVM 的理解？MVVM 是 Model-View-ViewModel 的缩写。Model 代表数据模型，Model 中定义数据修改和操作的业务逻辑。View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View。在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 二、Vue 的生命周期beforeCreate（创建前） 在数据观测和初始化事件还未开始created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来beforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。mounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页面中。此过程中进行 ajax 交互。beforeUpdate（更新前） 在数据更新之前调用，发生在虚拟 DOM 重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。updated（更新后） 在由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。调用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。beforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 1.什么是 vue 生命周期？答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、销毁等一系列过程，称之为 Vue 的生命周期。 2.vue 生命周期的作用是什么？答：它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。 3.vue 生命周期总共有几个阶段？答：它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。 4.第一次页面加载会触发哪几个钩子？答：会触发 下面这几个 beforeCreate, created, beforeMount, mounted 。 5.DOM 渲染在 哪个周期中就已经完成？答：DOM 渲染在 mounted 中就已经完成了。 三、 Vue 实现数据双向绑定的原理：Object.defineProperty()vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty（）来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue 的数据双向绑定 将 MVVM 作为数据绑定的入口，整合 Observer，Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 的数据变化，通过 Compile 来解析编译模板指令（vue 中是用来解析 { { } }），最终利用 watcher 搭起 observer 和 Compile 之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据 model 变更双向绑定效果。 js 实现简单的双向绑定 123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt; 四、Vue 组件间的参数传递1.父组件与子组件传值父组件传给子组件：子组件通过 props 方法接受数据;子组件传给父组件：\\$emit 方法传递参数 2.非父子组件间的数据传递，兄弟组件传值eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用 VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。） 五、Vue 的路由实现：hash 模式 和 history 模式hash 模式：在浏览器中符号“#”，#以及#后面的字符称之为 hash，用 window.location.hash 读取；特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.xxx.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history 模式：history 采用 HTML5 的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及 popState 事件的监听到状态变更。history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。” 六、vue 路由的钩子函数（守卫）首页可以控制导航跳转，beforeEach，afterEach 等，一般用于页面 title 的修改。一些需要登录才能调整页面的重定向功能。 beforeEach 主要有 3 个参数 to，from，next： to：route 即将进入的目标路由对象， from：route 当前导航正要离开的路由 next：function 一定要调用该方法 resolve 这个钩子。执行效果依赖 next 方法的调用参数。可以控制网页的跳转。 七、vuex 是什么？怎么使用？哪种功能场景使用它？只用来读取的状态集中放在 store 中； 改变状态的方式是提交 mutations，这是个同步的事物； 异步逻辑应该封装在 action 中。在 main.js 引入 store，注入。新建了一个目录 store，….. export 。场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车stateVuex 使用单一状态树,即每个应用将仅仅包含一个 store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。mutationsmutations 定义的方法动态修改 Vuex 的 store 中的状态或数据。getters类似 vue 的计算属性，主要用来过滤一些数据。actionactions 可以理解为通过将 mutations 里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 123456789101112131415const store = new Vuex.Store(&#123; //store实例 state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit(&apos;increment&apos;) &#125; &#125;&#125;) modules项目特别复杂的时候，可以让每一个模块拥有自己的 state、mutation、action、getters,使得结构非常清晰，方便管理。 1234567891011121314151617const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125; &#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125; &#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB&#125;) 八、keep-alive 的了解？keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。在 vue 2.1.0 版本之后，keep-alive 新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于 include) 。 使用方法 12345&lt;keep-alive include=&apos;include_components&apos; exclude=&apos;exclude_components&apos;&gt; &lt;component&gt; &lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt; &lt;/component&gt;&lt;/keep-alive&gt; 参数解释include - 字符串或正则表达式，只有名称匹配的组件会被缓存exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用 v-bind 。 使用示例 1234567891011121314&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;&lt;keep-alive :include=&quot;[&apos;a&apos;, &apos;b&apos;]&quot;&gt; &lt;component&gt;&lt;/component&gt;&lt;/keep-alive&gt; 一句话就能回答的面试题1.css只在当前组件起作用答：在style标签中写入scoped即可 例如： 2.v-if 和 v-show 区别答：v-if按照条件是否渲染，v-show是display的block或none； 3.$route和$router的区别答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 4.vue.js的两个核心是什么？答：数据驱动、组件系统(angular的指令服务) 5.vue几种常用的指令答：v-for 、 v-if 、v-bind、v-on、v-show、v-else 6.vue常用的修饰符？答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用 7.v-on 可以绑定多个方法吗？答：可以 8.vue中 key 值的作用？答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。 9.什么是vue的计算属性？答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。 10.vue等单页面应用及其优缺点答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。 PS：缺少的案例代码，这几天再补上去。有些地方可能描述的不够清楚，如果有歧义，可能是我理解错了。看到这你如果还不够过瘾，我给你一个链接 思否81道够你查漏补缺，我这式常见的。","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://achengacheng.github.io/tags/Vue/"}]},{"title":"Vue原理篇","slug":"Vue原理篇","date":"2018-11-27T06:02:47.000Z","updated":"2019-07-13T11:14:48.516Z","comments":true,"path":"2018/11/27/Vue原理篇/","link":"","permalink":"http://achengacheng.github.io/2018/11/27/Vue原理篇/","excerpt":"","text":"MVVM 设计模式:网页组成:HTML 内容CSS 样式JS 交互行为问题: JS 的功能过于集中: 即要操作数据，又要操作界面！扩展，易读维护成本高 重新划分:View 视图 指网页中的元素和样式 HTML/CSSModel 模型 指程序中创建的或从远程获取的数据ViewModel 视图模型/控制器封装之前的 DOM/JQUERY 操作, 把模型数据绑定到视图中指定位置绑定: 不需要写一行代码，就可让页面元素内容和数据联动变化其实: Vue 类型，提供的就是一种强大的 ViewModel 对象可自动同步页面视图和数据设计模式原则：松耦合高内聚MVVM 设计模式: 松耦合视图的修改，与程序无关！ 使用 Vue: HTML 中, 创建视图 View, 其实就是以前的网页 JS 中，定义/ajax 获取模型数据，其实就是以前的对象/数组/变量 js 中，创建 Vue 类型的对象，将一个页面父元素与内存中一个数据对象绑定: 1234var vm=new Vue(&#123; el: &quot;选择器&quot;, data: 数据对象&#125;) 原理: new Vue()1.构建响应系统:为模型数据中的每个属性，添加访问器属性同时，将页面中的每个”{ { } }”加入监视队列只要修改模型数据的属性，就会自动调用vm对应属性的set方法, set会:①实际修改模型数据中的属性值②通知监视队列，找到受此数据修改影响元素，改变元素内容。 2.构建虚拟DOM树: Virtual DOM Tree什么是虚拟DOM树: 用js对象，描述出的DOM树为什么: 遍历js对象，比遍历DOM元素要快的多！ 因为js对象中只包含关心的属性，不包含多余属性 而DOM元素的属性却极其庞大！何时: 每次模型数据更新时，都会重新创建虚拟DOM树 然后，比对新旧两棵树，仅找到变化的节点,仅将变化的节点，实际修改到DOM树上为什么快: 1. 仅包含关心的节点和数据 2. 局部更新DOM树，避免大范围重排重绘 3. 自动化的增删改查DOM操作，无需人工 实现 Vue 响应原理：访问器属性什么是访问器属性：不直接存储属性值，专门对其它属性提供保护的特殊属性何时: 只要使用自定义规则保护属性时如何: 2 步:1、定义一个闭包结构，实际存储属性值2、定义一个访问器属性来保护闭包中的局部变量 1234Object.defineProperty(obj, prop, descriptor)//obj：必需。目标对象//prop：必需。需定义或修改的属性的名字//descriptor：必需。目标属性所拥有的特性 保护对象:问题: js 中的对象可随时添加/删除/修改任何属性解决: 对 js 中的对象提供保护！如何: 保护单个属性:如何: ES5 将属性重新分类: 1.数据属性: 直接存储属性值的属性 2.命名属性: 可用.直接访问的属性命名属性又分为: 1.数据属性: 直接存储属性值的属性 2.访问器属性: 不实际存储属性，专门提供对其它数据属性的保护！ 3.内部属性: 不能用.直接访问的属性保护数据属性:ES5 中将每个属性，又细分为四大特性: 12345678910 &#123; id:1001 &#123; value:1001, //实际存储属性值 writable:true, //控制是否可修改 enumerable:true, //控制是否可被for in遍历 强调: 只防止for in, //不防止用.直接访问！ configurable:true, //控制: 是否可删除该属性,是否可修改前两个特性一旦改为false，不可逆！ &#125;&#125; 获取一个属性的四大特性:var attrs=Object.getOwnPropertyDescriptor(obj,”属性”) 修改属性的四大特性，保护属性: 仅修改一个属性的四大特性: 12345 Object.defineProperty(obj,&quot;属性&quot;,&#123; writable:false, … …&#125;) 批量修改多个属性的四大特性: 12345Object.defineProperties(obj,&#123; 属性:&#123; 四大特性 …&#125;, 属性:&#123; 四大特性 …&#125;,… : …&#125;) 问题: 无法使用自定义规则保护属性解决: 用访问器属性保护数据属性用访问器属性，保护数据属性:什么是访问器属性: 不实际存储属性值，只提供对其它数据属性的保护何时: 要用自定义规则保护属性时如何: 1.前提: 先创建一个受保护的隐藏的数据属性，用于实际存储属性值！ 2.定义: 必须用 Object.defineProperty/defineProperties 定义，且也有四大特性: 123456789101112Object.defineProperty(obj,&quot;访问器属性名&quot;,&#123; get:function()&#123; return this.数据属性 &#125;, set:function(value)&#123; //value 会自动收到要赋的新值 if(value 满足条件) this.数据属性=值; else throw new Error(&quot;错误提示&quot;) &#125;, enumerable:true, configurable:true&#125;) 使用: 访问器属性的用法和普通属性的用法完全一样 1console.log(eric.age) //获取 eric 的 age 自动调用 eric.age 的 get()eric.age=27 //修改 eric 的 age自动调用 eric.age 的 set(27) 保护对象结构:什么是: 禁止添加/删除属性包括: 3 个级别: 防扩展: 禁止添加新属性！如何: Object.preventExtensions(obj)原理: 每个对象中都有一个隐藏的内部 extensible:truepreventExtensions()将对象的 extensible 改为 false 密封: 在兼具防扩展同时禁止删除任何属性如何: Object.seal(obj)原理: 在修改 extensible:false 同时，自动修改每个属性的 configurable 为 false 冻结: 在兼具密封的基础上，禁止修改一切属性值！如何: Object.freeze(obj)原理: 修改 extensible:false修改每个属性的 configurable 为 false修改每个属性的 writable 为 false Vue实现数据双向绑定的原理：Object.defineProperty()vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析 { { } }），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。 js实现简单的双向绑定123456789101112131415161718192021&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt; &lt;p id=&quot;show&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var obj = &#123;&#125; Object.defineProperty(obj, &apos;txt&apos;, &#123; get: function () &#123; return obj &#125;, set: function (newValue) &#123; document.getElementById(&apos;txt&apos;).value = newValue document.getElementById(&apos;show&apos;).innerHTML = newValue &#125; &#125;) document.addEventListener(&apos;keyup&apos;, function (e) &#123; obj.txt = e.target.value &#125;)&lt;/script&gt;","categories":[],"tags":[{"name":"Vue.js-设计模式","slug":"Vue-js-设计模式","permalink":"http://achengacheng.github.io/tags/Vue-js-设计模式/"}]},{"title":"jquery常用干货（不间断更新）","slug":"jquery常用干货","date":"2018-11-07T03:56:22.000Z","updated":"2019-02-16T08:27:15.416Z","comments":true,"path":"2018/11/07/jquery常用干货/","link":"","permalink":"http://achengacheng.github.io/2018/11/07/jquery常用干货/","excerpt":"","text":"时区转换(基本每个项目都会有，经常还会成为 BUG 存在，我写一个时间问题没有写时区的处理，被领导认为我技术菜，受教育了，所以加深一波影响)123456789(_offset)=&gt;&#123; var _offset = (new Date().getTimezoneOffset() / 60) + 8; //时区差 var offset = _offset * 3600 * 1000; if (_offset &gt; 0) &#123; offset = -offset; &#125; else &#123; offset = Math.abs(offset); &#125;&#125; 插件(后端大佬让写一个“工具”，我一脸懵逼，发呆了很久不知如何下手，不是因为功能，而是不理解工具，我是有多弱智，我就问了下….)什么是: 具有独立样式和功能的小组件何时: 重用功能包括:1. 官方: jQuery UI 下载: jquery ui 引入: link css/jquery-ui.css script js/jquery-1.11.3.js script js/jquery-ui.js 按插件规定，定义HTML内容: 调用插件函数: 原理: 侵入: 插件自动根据需要，为元素添加属性和行为 优: 使用简单！ 缺: 极其不便于维护！ 插件 vs bootStroop:原理: DIY缺: 麻烦！优: 便于维护！ 如何选择: 1. 尽在自己的项目内，小范围使用: 采用jQueryUI方式 2. 如果是开放的插件，采用boot DIY的方式 2. 自定义插件:前提: 已经成功实现了该插件的样式和行为 1. jQuery UI 侵入: 如何定义: 1. 整理,并提取CSS到一个独立的css文件中 强调: 避免插件/组件间样式冲突 为整个组件定义一个顶级样式类的名字 组件内所有选择器必须以顶级样式类开头 2. 在独立的js文件中，为jQuery类型扩展新的插件函数: 2件事: 1. 自动侵入class和自定义扩展属性 2. 绑定事件 如何使用: 1. 在HTML页面中引入css文件 2. 按插件要求，编写HTML内容 3. 引入jquery.js, 和插件.js文件 4. 调用插件函数 2. BootStroop DIY: 如何定义: 1. 整理并提取css到独立css文件，同jQueryUI 2. 定义独立的js文件: 1件事: 查找元素，并绑定事件 如何使用: 1. 引入css 2. 按插件要求编写HTML内容 但，需要按插件要求手动添加class和data-*扩展属性 3. 引入jquery和插件.js 动画:（19.2.16 今天我些 vue 动画发现我的动画基础很差,由于长事件没有写过动画，canvas，SVG 导致我现在对动画知识点忘记大半，特来复习） 1.什么是动画(基础部分)使元素从一种样式逐渐变为另一种样式，即将多个过渡效果放在一起动画是通过”关键帧”，来控制动画的每一步。关键帧： 1.动画执行的时间点 2.在该时间点上的样式是什么 2.动画的使用步骤 1.声明动画 123456789101112@keyframes 动画名称&#123; /_定义关键帧_/ 0%&#123; /_动画开始时的样式_/ &#125; 50%&#123; /_动画执行到一半时元素的样式_/ &#125; 100%&#123; /_动画结束时元素的样式_/ &#125;&#125; 2.为元素调用动画1.animation-name作用：指定调用动画的名称2.animation-duration作用：指定动画执行一个周期的时长取值：以 s 或 ms 为单位的数字3.animation-timing-function作用：指定动画的速度时间曲线函数取值：ease/linear/ease-in/ease-out/ease-in-out4.animation-delay作用:指定动画的延迟时间取值：以 s 或 ms 为单位的数字5.animation-iteration-count作用：指定动画的播放次数取值： 1.具体数字2.infinite 无限次播放6.animation-direction作用：指定动画的播放方向取值：1.normal 默认值，正常从 0%到 100%2.reverse 逆向播放从 100%到 0%3.alternate 轮流播放奇数次数播放时，正向播放的偶数次数播放时，逆向播放的7.动画的简写方式animation:name duration timing-function delay iteration-count direction;8.animation-fill-mode作用：规定动画在播放前或播放后的状态取值：1.none 默认值2.forwards 动画播放完以后，将保持在最后一个帧的状态上3.backwards 动画播放前，延迟时间内，动画保持在第一帧的状态上4.both 是 forwards 和 backwards 的结合体9.animation-play-state作用：指定动画是出于播放还是暂停的状态上取值：1.paused 暂停2.running 播放 (jquery 部分) 动画: 简单动画: 3 组效果:显示隐藏: .show([ms]) .hide([ms]) .toggle([ms])强调: .show()/.hide() 如果不加参数，默认是 display:block/none，不带动画效果——推荐上滑下滑: .slideUp(ms) .slideDown(ms) .slideToggle(ms)淡入淡出: .fadeIn() .fadeOut() .fadeToggle()原理: 用 js 的定时器修改的内联样式:问题: 1. 效率不如 css 的 transition 2. 写死的效果，不可维护 万能动画: 可对多数 css 属性选择应用动画效果$elem.animate({css 属性名: 目标值,… : …},ms)强调: 只支持单个数值的 css 属性排队和并发: 并发: 多个 css 属性，同时变化如何: 在一个 animate 内的多个 css 属性，默认并发 排队: 多个 css 属性，排队先后变化如何: 对一个元素，先后调用多个 animate，则排队执行其它动画 API，也有排队效果。本质: 调用动画 API，不是立刻启动动画的意思。只是将动画加入队列而已。动画播放后执行:每个动画 API 的最后一个参数，都是一个回调函数，会在动画播放后自动执行!停止动画: .stop()问题: 默认只能停止队列中当前正在播放的一个动画，后续动画依然执行解决: .stop(true) 清空队列选择器: :animated 选择或判断一个正在播放动画的元素延迟执行: .delay(ms)","categories":[],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://achengacheng.github.io/tags/Jquery/"}]},{"title":"初探设计模式","slug":"设计模式","date":"2018-10-02T01:57:35.000Z","updated":"2019-02-10T07:29:51.471Z","comments":true,"path":"2018/10/02/设计模式/","link":"","permalink":"http://achengacheng.github.io/2018/10/02/设计模式/","excerpt":"","text":"如果你想了解什么是设计模式？我觉得以下代码很好理解。展现内容我就不依次展示了，可复制代码查看。两段代码展现功能相同。拿到需求我第一次一定会写这样的代码123456789101112131415&lt;body&gt; &lt;button type=&quot;button&quot; id=&quot;like&quot;&gt;喜欢&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var likeBtn=document.getElementById(&quot;like&quot;); likeBtn.onclick=function()&#123; if(this.innerHTML==&quot;喜欢&quot;)&#123; this.innerHTML=&apos;已赞&apos; this.style.color=&quot;red&quot;; &#125;else&#123; this.innerHTML=&quot;喜欢&quot; this.style.color=&quot;blue&quot;; &#125; &#125;&lt;/script&gt; 感受以下设计模式带来的可扩展性1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;button type=&quot;button&quot; id=&quot;like&quot;&gt;喜欢&lt;/button&gt;&lt;/body&gt;&lt;script&gt; // state var likeBtn=document.getElementById(&apos;like&apos;); // 状态 var state=&#123; like:false, color:&quot;red&quot; &#125; // 设置状态 var setState=function(newState)&#123; state=&#123; ...state, ...newState &#125; &#125; //渲染 var render=function()&#123; if(state.like)&#123; likeBtn.innerHTML=&quot;已赞&quot;; likeBtn.style.color=&quot;red&quot; &#125;else&#123; likeBtn.innerHTML=&quot;喜欢&quot;; likeBtn.style.color=&quot;black&quot;; &#125; &#125; //控制器 likeBtn.addEventListener(&apos;click&apos;,function()&#123; setState(&#123; like : !state.like &#125;) &#125;)&lt;/script&gt;","categories":[],"tags":[{"name":"object","slug":"object","permalink":"http://achengacheng.github.io/tags/object/"},{"name":"设计模式","slug":"设计模式","permalink":"http://achengacheng.github.io/tags/设计模式/"}]},{"title":"模拟假数据","slug":"falseData","date":"2018-09-27T04:56:22.000Z","updated":"2019-02-10T07:15:02.363Z","comments":true,"path":"2018/09/27/falseData/","link":"","permalink":"http://achengacheng.github.io/2018/09/27/falseData/","excerpt":"","text":"写本文的原因：技术人员都很Lzay,大多数情况自己去做一些假数据来测试最基本一些功能的完整性。我写接口是用node.js+express框架+mysql/mongoDB数据库搭建的后端来测试，基本是写出来一个demo，之后无限套用，改路由配置就完了。但是在最近我重新温习vue的过程中我发现一些好玩的东西：假数据！假数据！假数据！免费的的假数据库！可以测试线上的！(第三) 1. jsonplaceholder这个是最简单的测试用数据测试网站用户列表http://jsonplaceholder.typicode.com/usersget请求http://jsonplaceholder.typicode.com/posts 2.jsonServer安装使用步骤:2.1输入npm install -g json-server 安装json-server全局 3.2输入npm init 初始化一个package.json文件 3.3输入npm install json-server –save 安装一个json-server模块 3.4修改一下package.json的启动方式，方便启动 3.5创建一个db.json,编写一些假数据(对象数组方式) 3.6新建一个READNME.md文件，方便用户使用 3.7终端输入 npm run json:server 启动json:server打开浏览器，输入项目启动的地址(localhost:3000)前端请求http://localhost:3000/xxxx数据就好 3.8下载POSTman来演示几个常用的请求(#get请求,#post请求) 2.firebaseio https:www.firebaseio.com(谷歌邮箱登陆)谷歌邮箱登陆(我比较喜欢用这个傻瓜式注册，自己直接写数据，以后自己不通过GitHub搭博客自己纯手工开发我就用它，免费好用，有兴趣可以玩)试试看看现在能用吗？因为我内网穿透所以可以用。 4.国内野狗：www.wilddog.com2018-03-16 “野狗”创始人兼CEO刘之对外宣布，公司资金出现问题，重组计划推进缓慢，所以，即将停止新用户注册，服务将持续运营，直至老用户完全迁出，试试看看现在能用吗？截至到我发表这篇文章为止我还不能重新注册新的账户。类似于国外firebaseio，都很好用。","categories":[],"tags":[{"name":"firebaseio","slug":"firebaseio","permalink":"http://achengacheng.github.io/tags/firebaseio/"},{"name":"jsonServer","slug":"jsonServer","permalink":"http://achengacheng.github.io/tags/jsonServer/"}]},{"title":"原理图","slug":"原理图","date":"2018-08-11T06:52:12.000Z","updated":"2019-07-13T11:13:55.609Z","comments":true,"path":"2018/08/11/原理图/","link":"","permalink":"http://achengacheng.github.io/2018/08/11/原理图/","excerpt":"","text":"最近总结的一些图片有助于理解一些难理解的内容原型链:什么是: 由多级父对象逐级继承形成的链式结构 保存着: 所有对象的属性 控制着: 对象成员的使用顺序和使用范围顺序: 先自有，再向上范围: 越上层的成员，共享范围越大！ 原型链vs 作用域链:保存着所有不带.的变量控制着变量的使用顺序: 先局部，后全局 总结:只要不用.就可直接访问的变量，默认仅在作用域链中找必须用.(点)才能访问的变量，都在各自的原型链中查找 jquery很多人面试都被问到一道的面试题：你看过什么源码？你自己封装过一些常用插件吗？这张图能看懂就不怕面试这类题。","categories":[],"tags":[{"name":"photo","slug":"photo","permalink":"http://achengacheng.github.io/tags/photo/"}]},{"title":"读javaScript设计模式第一章--笔记","slug":"javascript设计模式object","date":"2018-07-10T01:57:35.000Z","updated":"2019-02-16T07:40:35.489Z","comments":true,"path":"2018/07/10/javascript设计模式object/","link":"","permalink":"http://achengacheng.github.io/2018/07/10/javascript设计模式object/","excerpt":"","text":"设计模式是一种解决问题的模式(模板)，功效高模块化开发能力(可维护，高效率，可扩展)设计原则与代码重构函数和变量之间的关系：函数声明和变量声明都是指开辟了一片储存值的空间变量和函数值由堆栈存储。什么是堆栈？ 堆 引用类型 栈 基本类型 变量 堆是由栈组成函数直接量声明(面向过程编程)函数式编程？需求由函数执行(函数解决需求)面向对象编程？需求抽象成对象，由对象方法方式实现功能 功能 ：验证用户名，邮箱，密码。函数直接量：123456789function checkName()&#123; //验证姓名&#125;function checkEmail()&#123; //验证邮箱&#125;function checkPassword()&#123; //验证密码&#125; 函数创建即变量，变量变化即函数，函数即变量 函数的另一种形式 需要提前声明123456789var checkName=function()&#123; //验证姓名&#125;var checkEmail=function()&#123; //验证邮箱&#125;var checkPassword=function()&#123; //验证密码&#125; 用的时候再调用变量声明,保护内存。 对象收编变量1234567891011var CheckObject=&#123; CheckName:function()&#123; //验证姓名 &#125;, checkEmail:function()&#123; //验证邮箱 &#125;, checkPassword:function()&#123; //验证密码 &#125; &#125; 减少函数命名风险：将多个函数变量保存在一个变量里，创建复合功能的对象，访问储存值通过遍历访问它的属性和方法，函数种如果属性或者方法不发生改变那么它不会重新重新渲染。只改变已变化的量 对象的另一种创建方式，添加属性，方法12345678910var CheckObject=function()&#123;&#125;; CheckObject.checkName=function()&#123; //验证姓名 &#125; CheckObject.checkEmail=function()&#123; //验证邮箱 &#125; CheckObject.checkPassword=function()&#123; //验证密码 &#125; 以上代码只达到了封装，没有继承多态特性简单的面向对象理解，我们大多数人了解到仅此而已 面向对象进阶工作了一年，我还没有用到继承类是不是有点low /哈哈\\这块知识有助于学习框架的底层，包括理解函数库。自己封装插件 对象 new 机制12345678910111213var CheckObject=function()&#123; return&#123; checkName:function()&#123; //验证姓名 &#125;, checkEmail:function()&#123; // 验证邮箱 &#125;, checkPassword:function()&#123; // 验证密码 &#125; &#125; &#125; 这样每次调用这个函数时都返回了一个新对象，这个每个人使用就会互不影响，每次使用在调用以上代码并不是真正意义上类的创建 返回出来的对象与原来 CheckObject 对象本身无关 对象类1234567891011var CheckObject=function()&#123; this.checkName=function()&#123; // 验证姓名 &#125; this.checkEmail=function()&#123; // 验证邮箱 &#125; this.checkPassword=function()&#123; // 验证密码 &#125; &#125; javaScript本身没有类的概念，引用java面向对象类，ES6中首次提出类的概念也只是模仿类的写法(某大佬全栈告知)类：类必须使用 new 关键字创建，this 可以理解为继承的关键，对象中看到this说明使用了继承然而每次调用 new 返回新的对象都会对类的 this 上的属性进行复制，原值不会变，所以这些新创建的对象都自己独有的方法，然而这样做消耗内存。 prototype1.1 这两种方式不能混用逐个添加：12345678910var CheckObject=function()&#123;&#125;;CheckObject.prototype.checkName=function()&#123; //验证姓名&#125;CheckObject.prototype.checkEmail=function()&#123; // 验证邮箱&#125;CheckObject.prototype.checkPassword=function()&#123; // 验证密码&#125; 添加简化： 1234567891011121314var CheckObject=function()&#123;&#125;;CheckObject.prototype=&#123; checkName:function()&#123; //验证姓名 &#125;, checkEmail:function()&#123; //验证邮箱 &#125;, checkPassword:function()&#123; // 验证密码 &#125;&#125;var a= new CheckObject();a.checkName(); 这样创建对象的实例，创建出来它们都会依赖 prototype 原型依次寻找，找到的方法都是同一个，所以它们都绑定在 CheckObject 对象类的原型上。如果需求只有很小的改变，那么我们可以在new出来新对象的基础上去改变添加它的方法，利用多态的重写机制 ##1.3 如果想链式调用123456789101112131415161718var CheckObject=function()&#123;&#125;; CheckObject.prototype=&#123; checkName:function()&#123; //验证姓名 return this; &#125;, checkEmail:function()&#123; //验证邮箱 return this; &#125;, checkPassword:function()&#123; // 验证密码 return this; &#125;&#125; //调用方法 var a= new CheckObject(); a.checkName().checkEmail().checkPassword() 在声明的每一个方法后返回当前对象，这样每次调用后都可以链式操作。jquery(循环，链接)都是this关于this指向问题，等我搞的清楚后再来写 抽象出一个统一添加方法的功能方法真正意义函数式编程12345678910111213141516171819Function.protoype.addMethod=function(name,fn)&#123; this[name]=fn 链式添加方法 return this &#125;var methods=new Function();methods.addMethod(&apos;cheeekName&apos;,function()&#123; // 验证姓名 链式调用 return this &#125;) methods.addMethod(&apos;checkEmail&apos;,function()&#123; // 验证邮箱 链式调用 return this &#125;) methods.checkName(); methods.checkEmail(); methods.checkEmail().checkName() 返回出新的对象后提供添加后续功能使用(函数构造器，构造新的函数， 将功能和规则分离)react原理！！！（现在还不太懂，慢慢进步） 类式调用方式(最佳方案)我第一次看有点懵，多读几遍其意自现，可能是我了解的不够深刻，将核心内容将不太来。留点悬念吧。12345678910111213Function.prototype.addMethod=function(name,fn)&#123; this.prototype[name]=fn; return this;&#125;var methods=function()&#123;&#125;methods.addMethod(&apos;checkName&apos;,()=&gt;&#123; //验证姓名 return this;&#125;).methods.addMethod(&apos;checkEmail&apos;,()=&gt;&#123; // 验证邮箱&#125;)var check=new method();methods.checkEmail() 封装(使用时再创建)继承(原型链)多态(重载，重写) 第一遍读是7月，后续我没修改。","categories":[],"tags":[{"name":"object","slug":"object","permalink":"http://achengacheng.github.io/tags/object/"},{"name":"设计模式","slug":"设计模式","permalink":"http://achengacheng.github.io/tags/设计模式/"}]},{"title":"WebpackReact","slug":"WebpackReact","date":"2018-06-20T03:56:22.000Z","updated":"2019-02-10T06:51:18.640Z","comments":true,"path":"2018/06/20/WebpackReact/","link":"","permalink":"http://achengacheng.github.io/2018/06/20/WebpackReact/","excerpt":"","text":"本站只提供参考，不保证内容的完整准确性，谨慎参考！ Reacr 前期 webpack 配置注：脚手架搭建的项目首次使用需要配置 git，如果想配置则需要删除隐藏文件 git 相关文件1.初始化 webpacknpm init 2.安装开发依赖npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env @babel/preset-react -D-D 表示开发环境@babel/core @babel/preset-env @babel/preset-react 建议安装最新版的，在 webpack 打包中，会因为版本的冲突报错影响打包，所以建议安装最新版本的 3.安装 react 生产依赖npm install react react-dom -S-S 表示生产环境 4.在当前项目目录下创建 webpack.config.js 写配置文件如果要引入.less的文件 就必须安装相对应依赖 npm i less style-loader css-loader less-loader -D然后在webpack.config.js中写配置 注意：在配置use : [“style-loader”,”css-loader”,”less-loader”] 顺序一定不能变。5.新建一个JS文件 ，测试当前安装的webpack能否完成打包 6.安装webpack热更新(根据项目的代码自动完成打包，就不需要每次写完代码重新webpack一次)npm install webpack-dev-server -D然后在webpack.cong.js写入配置然后进入package.json 加如下代码：这个时候运行npm run start可以访问localhost:8080 记得把index.html文件放到dist文件下，这个时候整个项目就可以运行了","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://achengacheng.github.io/tags/React/"},{"name":"webpack","slug":"webpack","permalink":"http://achengacheng.github.io/tags/webpack/"}]},{"title":"hexo+github","slug":"demo","date":"2018-05-24T03:11:11.000Z","updated":"2018-06-19T15:55:54.000Z","comments":true,"path":"2018/05/24/demo/","link":"","permalink":"http://achengacheng.github.io/2018/05/24/demo/","excerpt":"","text":"#这是一个测试我来复习一下hexo+github.","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://achengacheng.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://achengacheng.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://achengacheng.github.io/tags/github/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo+github搭建个人博客","date":"2018-05-24T03:11:11.000Z","updated":"2019-02-09T07:06:57.214Z","comments":true,"path":"2018/05/24/hexo+github搭建个人博客/","link":"","permalink":"http://achengacheng.github.io/2018/05/24/hexo+github搭建个人博客/","excerpt":"","text":"本站只提供参考，不保证内容的完整准确性，不喜勿喷。欢迎来到hexo+github博客搭建教程，这是一篇比较繁琐的blog，本人亲自实战操作经验。 环境配置node环境 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。浏览器打开node官网下载8.11.2版本的msi双击安装 环境测试 win+r打开运行窗口，输入cmd回车 在cmd窗口输入1node -v 如果提示”node不是内部或外部命令”，需要重新安装node如果提示v8.11.2则代表安装成功 git服务 浏览器打开git官网，下载最新版的git安装 安装完毕以后，在桌面右键菜单出现git bash here则代表安装成功 安装hexo脚手架 win+r打开运行窗口，输入cmd回车 在命令行输入1npm install hexo-cli -g 通过npm包管理器全局安装hexo脚手架 博客搭建初始化博客项目 桌面右键选择git bash here 在命令行窗口输入1hexo init blog 通过hexo在桌面新建一个叫blog的博客项目ps:blog是项目名称，名字随意，但不能是中文 切换到blog路径 1cd blog 安装项目依赖 1npm install 启动服务器 1hexo s 预览博客浏览器地址栏输入localhost:4000或者127.0.0.1:4000回车ps：建议使用chrome(谷歌浏览器) hexo常规操作 清理项目缓存1hexo clean 何时使用？修改了博客内容却没有效果或者修复了bug报错依然存在 编译博客1hexo g 何时使用？每次hexo clean之后都需要重新编译部分情况下修改了_config.yml配置文件后需要重新编译手动新建博客文章之后需要重新编译 重启服务器在之前启动服务的命令行窗口使用快捷键”ctrl+c”可以停止hexo服务然后紧接着输入hexo s启动何时使用？修改了_config.yml需要重启服务 hexo项目托管到github本机验证github的key 打开github 注册个人账号并记录下用域名和邮箱，并且验证邮箱 桌面右键打开git bash here 1ssh-keygen -t rsa -C &quot;邮箱&quot; 接下来依次打开：c:/Users/Administrator/.ssh路径找到：id_rsa.pub文件右键选择记事本打开，全选并复制里面的内容(key) 回到github页面，找到头像右侧倒三角下拉菜单，选择settings 在页面左侧选择ssh and gpk 点击右上角绿色 add ssh按钮 在表单输入title(随意)和key(粘贴之前复制到的key)然后点击绿色create ssh按钮 回到刚才创建key的命令行窗口验证用户名和邮箱12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot; 如果验证成功，没有任何提示。 创建github用户名同名仓库在github页面点击头像左侧的+，选择New repository重点:仓库名必须是:用户名.github.io,严格区分大小写，如：假如用户名为aBc，那么仓库名就为:aBc.github.io 配置hexo找到项目主目录下的_config.yml文件在文档的最下方添加如下内容：1234deploy: type: git repository: http://github.com/用户名/用户名.github.io branch: master 注意：用户名严格区分大小写ps：整个项目有2个_config.yml根目录的_config.yml负责整个项目的一些配置，如：博客名称、语言等themes文件夹内的_config.yml负责主题样式方面的配置 项目推送（这是重点） 安装gcmw（解压压缩包，双击install.cmd） 打开博客项目根目录，右键git bash here 安装deployer-git依赖 1npm install hexo-deployer-git --save 依次执行如下命令 1hexo clean 重新编译1hexo g 推送1hexo d 中途会弹出github的验证，输入相应的应户名密码就好 如果推送成功，在浏览器打开http://用户名.github.io即可访问 #主题更换设置 在github主题库或者问候度娘，找到喜欢的主题然后复制下载命令 安装依赖：npm install hexo 。。。。（此处点点是每个主题不一样命令不同） 在blog文件的主题目录下找到_config.yml 中的theme改为主题名称 重启服务——预览 #留言版功能：本人用的valine","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://achengacheng.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://achengacheng.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://achengacheng.github.io/tags/github/"}]},{"title":"置顶","slug":"置顶","date":"2018-04-09T14:56:02.000Z","updated":"2019-07-13T11:14:47.759Z","comments":true,"path":"2018/04/09/置顶/","link":"","permalink":"http://achengacheng.github.io/2018/04/09/置顶/","excerpt":"","text":"前端里程碑谢谢github,好好利用,定个小任务每月一次跟新技术概况，记录每个月自己技术的成长，今天天气晴，地点：酒泉。","categories":[],"tags":[{"name":"diary","slug":"diary","permalink":"http://achengacheng.github.io/tags/diary/"}]}]}