{"meta":{"title":"BLOG","subtitle":"附标题","description":"描写","author":"NIUHONGGUI","url":"http://niuhonggui.github.io"},"pages":[{"title":"Home","date":"2018-05-25T03:22:38.000Z","updated":"2019-02-10T07:35:23.055Z","comments":true,"path":"Home/index.html","permalink":"http://niuhonggui.github.io/Home/index.html","excerpt":"","text":"这个人很懒，home什么都没留下"},{"title":"about","date":"2018-05-25T03:22:06.000Z","updated":"2019-02-10T07:36:44.589Z","comments":true,"path":"about/index.html","permalink":"http://niuhonggui.github.io/about/index.html","excerpt":"","text":"这个人很懒，about 什么都没留下"},{"title":"相册","date":"2018-05-25T03:20:51.000Z","updated":"2019-02-10T07:37:12.223Z","comments":true,"path":"相册/index.html","permalink":"http://niuhonggui.github.io/相册/index.html","excerpt":"","text":"这个人很懒，相册 什么都没留下"},{"title":"tags","date":"2018-05-25T03:20:51.000Z","updated":"2019-02-10T07:41:14.769Z","comments":true,"path":"tags/index.html","permalink":"http://niuhonggui.github.io/tags/index.html","excerpt":"","text":"这个人很懒tags什么都没留下"},{"title":"categories","date":"2018-05-25T03:20:18.000Z","updated":"2019-02-10T07:36:30.419Z","comments":true,"path":"categories/index.html","permalink":"http://niuhonggui.github.io/categories/index.html","excerpt":"","text":"这个人很懒，categories （分类）什么都没留下"}],"posts":[{"title":"WebpackReact","slug":"jquery常用干活","date":"2018-11-07T03:56:22.000Z","updated":"2019-02-10T10:01:22.924Z","comments":true,"path":"2018/11/07/jquery常用干活/","link":"","permalink":"http://niuhonggui.github.io/2018/11/07/jquery常用干活/","excerpt":"","text":"时区转换(基本每个项目都会有，经常还会成为 BUG 存在，我写一个时间问题没有写时区的处理，被领导认为我技术菜，受教育了，所以加深一波影响)123456789(_offset)=&gt;&#123; var _offset = (new Date().getTimezoneOffset() / 60) + 8; //时区差 var offset = _offset * 3600 * 1000; if (_offset &gt; 0) &#123; offset = -offset; &#125; else &#123; offset = Math.abs(offset); &#125;&#125; 插件(后端大佬让写一个“工具”，我一脸懵逼，发呆了很久不知如何下手，不是因为功能，而是不理解工具，我是有多弱智，我就问了下….)什么是: 具有独立样式和功能的小组件何时: 重用功能包括:1. 官方: jQuery UI 下载: jquery ui 引入: link css/jquery-ui.css script js/jquery-1.11.3.js script js/jquery-ui.js 按插件规定，定义HTML内容: 调用插件函数: 原理: 侵入: 插件自动根据需要，为元素添加属性和行为 优: 使用简单！ 缺: 极其不便于维护！ 插件 vs bootStroop: 原理: DIY 缺: 麻烦！ 优: 便于维护！ 如何选择: 1. 尽在自己的项目内，小范围使用: 采用jQueryUI方式 2. 如果是开放的插件，采用boot DIY的方式 2. 自定义插件:前提: 已经成功实现了该插件的样式和行为 1. jQuery UI 侵入: 如何定义: 1. 整理,并提取CSS到一个独立的css文件中 强调: 避免插件/组件间样式冲突 为整个组件定义一个顶级样式类的名字 组件内所有选择器必须以顶级样式类开头 2. 在独立的js文件中，为jQuery类型扩展新的插件函数: 2件事: 1. 自动侵入class和自定义扩展属性 2. 绑定事件 如何使用: 1. 在HTML页面中引入css文件 2. 按插件要求，编写HTML内容 3. 引入jquery.js, 和插件.js文件 4. 调用插件函数 2. BootStroop DIY: 如何定义: 1. 整理并提取css到独立css文件，同jQueryUI 2. 定义独立的js文件: 1件事: 查找元素，并绑定事件 如何使用: 1. 引入css 2. 按插件要求编写HTML内容 但，需要按插件要求手动添加class和data-*扩展属性 3. 引入jquery和插件.js","categories":[],"tags":[{"name":"Jquery","slug":"Jquery","permalink":"http://niuhonggui.github.io/tags/Jquery/"}]},{"title":"初探设计模式","slug":"设计模式","date":"2018-10-02T01:57:35.000Z","updated":"2019-02-10T07:29:51.471Z","comments":true,"path":"2018/10/02/设计模式/","link":"","permalink":"http://niuhonggui.github.io/2018/10/02/设计模式/","excerpt":"","text":"如果你想了解什么是设计模式？我觉得以下代码很好理解。展现内容我就不依次展示了，可复制代码查看。两段代码展现功能相同。拿到需求我第一次一定会写这样的代码123456789101112131415&lt;body&gt; &lt;button type=&quot;button&quot; id=&quot;like&quot;&gt;喜欢&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var likeBtn=document.getElementById(&quot;like&quot;); likeBtn.onclick=function()&#123; if(this.innerHTML==&quot;喜欢&quot;)&#123; this.innerHTML=&apos;已赞&apos; this.style.color=&quot;red&quot;; &#125;else&#123; this.innerHTML=&quot;喜欢&quot; this.style.color=&quot;blue&quot;; &#125; &#125;&lt;/script&gt; 感受以下设计模式带来的可扩展性1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;button type=&quot;button&quot; id=&quot;like&quot;&gt;喜欢&lt;/button&gt;&lt;/body&gt;&lt;script&gt; // state var likeBtn=document.getElementById(&apos;like&apos;); // 状态 var state=&#123; like:false, color:&quot;red&quot; &#125; // 设置状态 var setState=function(newState)&#123; state=&#123; ...state, ...newState &#125; &#125; //渲染 var render=function()&#123; if(state.like)&#123; likeBtn.innerHTML=&quot;已赞&quot;; likeBtn.style.color=&quot;red&quot; &#125;else&#123; likeBtn.innerHTML=&quot;喜欢&quot;; likeBtn.style.color=&quot;black&quot;; &#125; &#125; //控制器 likeBtn.addEventListener(&apos;click&apos;,function()&#123; setState(&#123; like : !state.like &#125;) &#125;)&lt;/script&gt;","categories":[],"tags":[{"name":"object","slug":"object","permalink":"http://niuhonggui.github.io/tags/object/"},{"name":"设计模式","slug":"设计模式","permalink":"http://niuhonggui.github.io/tags/设计模式/"}]},{"title":"模拟假数据","slug":"falseData","date":"2018-09-27T04:56:22.000Z","updated":"2019-02-10T07:15:02.363Z","comments":true,"path":"2018/09/27/falseData/","link":"","permalink":"http://niuhonggui.github.io/2018/09/27/falseData/","excerpt":"","text":"写本文的原因：技术人员都很Lzay,大多数情况自己去做一些假数据来测试最基本一些功能的完整性。我写接口是用node.js+express框架+mysql/mongoDB数据库搭建的后端来测试，基本是写出来一个demo，之后无限套用，改路由配置就完了。但是在最近我重新温习vue的过程中我发现一些好玩的东西：假数据！假数据！假数据！免费的的假数据库！可以测试线上的！(第三) 1. jsonplaceholder这个是最简单的测试用数据测试网站用户列表http://jsonplaceholder.typicode.com/usersget请求http://jsonplaceholder.typicode.com/posts 2.jsonServer安装使用步骤:2.1输入npm install -g json-server 安装json-server全局 3.2输入npm init 初始化一个package.json文件 3.3输入npm install json-server –save 安装一个json-server模块 3.4修改一下package.json的启动方式，方便启动 3.5创建一个db.json,编写一些假数据(对象数组方式) 3.6新建一个READNME.md文件，方便用户使用 3.7终端输入 npm run json:server 启动json:server打开浏览器，输入项目启动的地址(localhost:3000)前端请求http://localhost:3000/xxxx数据就好 3.8下载POSTman来演示几个常用的请求(#get请求,#post请求) 2.firebaseio https:www.firebaseio.com(谷歌邮箱登陆)谷歌邮箱登陆(我比较喜欢用这个傻瓜式注册，自己直接写数据，以后自己不通过GitHub搭博客自己纯手工开发我就用它，免费好用，有兴趣可以玩)试试看看现在能用吗？因为我内网穿透所以可以用。 4.国内野狗：www.wilddog.com2018-03-16 “野狗”创始人兼CEO刘之对外宣布，公司资金出现问题，重组计划推进缓慢，所以，即将停止新用户注册，服务将持续运营，直至老用户完全迁出，试试看看现在能用吗？截至到我发表这篇文章为止我还不能重新注册新的账户。类似于国外firebaseio，都很好用。","categories":[],"tags":[{"name":"firebaseio","slug":"firebaseio","permalink":"http://niuhonggui.github.io/tags/firebaseio/"},{"name":"jsonServer","slug":"jsonServer","permalink":"http://niuhonggui.github.io/tags/jsonServer/"}]},{"title":"原理图","slug":"原理图","date":"2018-08-11T06:52:12.000Z","updated":"2019-02-10T07:12:28.298Z","comments":true,"path":"2018/08/11/原理图/","link":"","permalink":"http://niuhonggui.github.io/2018/08/11/原理图/","excerpt":"","text":"最近总结的一些图片有助于理解一些难理解的内容原型链:什么是: 由多级父对象逐级继承形成的链式结构 保存着: 所有对象的属性 控制着: 对象成员的使用顺序和使用范围顺序: 先自有，再向上范围: 越上层的成员，共享范围越大！ 原型链vs 作用域链:保存着所有不带.的变量控制着变量的使用顺序: 先局部，后全局 总结:只要不用.就可直接访问的变量，默认仅在作用域链中找必须用.(点)才能访问的变量，都在各自的原型链中查找 jquery很多人面试都被问到一道的面试题：你看过什么源码？你自己封装过一些常用插件吗？这张图能看懂就不怕面试这类题。","categories":[],"tags":[{"name":"-photo","slug":"photo","permalink":"http://niuhonggui.github.io/tags/photo/"}]},{"title":"读javaScript设计模式第一章--笔记","slug":"javascript设计模式object","date":"2018-07-10T01:57:35.000Z","updated":"2019-02-10T07:17:43.423Z","comments":true,"path":"2018/07/10/javascript设计模式object/","link":"","permalink":"http://niuhonggui.github.io/2018/07/10/javascript设计模式object/","excerpt":"","text":"设计模式是一种解决问题的模式(模板)，功效高模块化开发能力(可维护，高效率，可扩展)设计原则与代码重构函数和变量之间的关系：函数声明和变量声明都是指开辟了一片储存值的空间变量和函数值由堆栈存储。什么是堆栈？ 堆 引用类型 栈 基本类型 变量 堆是由栈组成函数直接量声明(面向过程编程)函数式编程？需求由函数执行(函数解决需求)面向对象编程？需求抽象成对象，由对象方法方式实现功能 功能 ：验证用户名，邮箱，密码。函数直接量：123456789function checkName()&#123; //验证姓名&#125;function checkEmail()&#123; //验证邮箱&#125;function checkPassword()&#123; //验证密码&#125; 函数创建即变量，变量变化即函数，函数即变量 函数的另一种形式 需要提前声明123456789var checkName=function()&#123; //验证姓名&#125;var checkEmail=function()&#123; //验证邮箱&#125;var checkPassword=function()&#123; //验证密码&#125; 用的时候再调用变量声明,保护内存。 对象收编变量1234567891011var CheckObject=&#123; CheckName:function()&#123; //验证姓名 &#125;, checkEmail:function()&#123; //验证邮箱 &#125;, checkPassword:function()&#123; //验证密码 &#125; &#125; 减少函数命名风险：将多个函数变量保存在一个变量里，创建复合功能的对象，访问储存值通过遍历访问它的属性和方法，函数种如果属性或者方法不发生改变那么它不会重新重新渲染。只改变已变化的量 对象的另一种创建方式，添加属性，方法12345678910var CheckObject=function()&#123;&#125;; CheckObject.checkName=function()&#123; //验证姓名 &#125; CheckObject.checkEmail=function()&#123; //验证邮箱 &#125; CheckObject.checkPassword=function()&#123; //验证密码 &#125; 以上代码只达到了封装，没有继承多态特性简单的面向对象理解，我们大多数人了解到仅此而已 面向对象进阶工作了一年，我还没有用到继承类是不是有点low /哈哈\\这块知识有助于学习框架的底层，包括理解函数库。自己封装插件 对象 new 机制12345678910111213var CheckObject=function()&#123; return&#123; checkName:function()&#123; //验证姓名 &#125;, checkEmail:function()&#123; // 验证邮箱 &#125;, checkPassword:function()&#123; // 验证密码 &#125; &#125; &#125; 这样每次调用这个函数时都返回了一个新对象，这个每个人使用就会互不影响，每次使用在调用以上代码并不是真正意义上类的创建 返回出来的对象与原来 CheckObject 对象本身无关 对象类1234567891011var CheckObject=function()&#123; this.checkName=function()&#123; // 验证姓名 &#125; this.checkEmail=function()&#123; // 验证邮箱 &#125; this.checkPassword=function()&#123; // 验证密码 &#125; &#125; javaScript本身没有类的概念，引用java面向对象类，ES6中首次提出类的概念也只是模仿类的写法(某大佬全栈告知)类：类必须使用 new 关键字创建，this 可以理解为继承的关键，对象中看到this说明使用了继承然而每次调用 new 返回新的对象都会对类的 this 上的属性进行复制，原值不会变，所以这些新创建的对象都自己独有的方法，然而这样做消耗内存。 prototype1.1 这两种方式不能混用逐个添加：12345678910var CheckObject=function()&#123;&#125;;CheckObject.prototype.checkName=function()&#123; //验证姓名&#125;CheckObject.prototype.checkEmail=function()&#123; // 验证邮箱&#125;CheckObject.prototype.checkPassword=function()&#123; // 验证密码&#125; 添加简化： 1234567891011121314var CheckObject=function()&#123;&#125;;CheckObject.prototype=&#123; checkName:function()&#123; //验证姓名 &#125;, checkEmail:function()&#123; //验证邮箱 &#125;, checkPassword:function()&#123; // 验证密码 &#125;&#125;var a= new CheckObject();a.checkName(); 这样创建对象的实例，创建出来它们都会依赖 prototype 原型依次寻找，找到的方法都是同一个，所以它们都绑定在 CheckObject 对象类的原型上。如果需求只有很小的改变，那么我们可以在new出来新对象的基础上去改变添加它的方法，利用多态的重写机制 ##1.3 如果想链式调用123456789101112131415161718var CheckObject=function()&#123;&#125;; CheckObject.prototype=&#123; checkName:function()&#123; //验证姓名 return this; &#125;, checkEmail:function()&#123; //验证邮箱 return this; &#125;, checkPassword:function()&#123; // 验证密码 return this; &#125;&#125; //调用方法 var a= new CheckObject(); a.checkName().checkEmail().checkPassword() 在声明的每一个方法后返回当前对象，这样每次调用后都可以链式操作。jquery(循环，链接)都是this关于this指向问题，等我搞的清楚后再来写 抽象出一个统一添加方法的功能方法真正意义函数式编程12345678910111213141516171819Function.protoype.addMethod=function(name,fn)&#123; this[name]=fn 链式添加方法 return this &#125;var methods=new Function();methods.addMethod(&apos;cheeekName&apos;,function()&#123; // 验证姓名 链式调用 return this &#125;) methods.addMethod(&apos;checkEmail&apos;,function()&#123; // 验证邮箱 链式调用 return this &#125;) methods.checkName(); methods.checkEmail(); methods.checkEmail().checkName() 返回出新的对象后提供添加后续功能使用(函数构造器，构造新的函数， 将功能和规则分离)react原理！！！（现在还不太懂，慢慢进步） 类式调用方式(最佳方案)我第一次看有点懵，多读几遍其意自现，可能是我了解的不够深刻，将核心内容将不太来。留点悬念吧。12345678910111213Function.prototype.addMethod=function(name,fn)&#123; this.prototype[name]=fn; return this;&#125;var methods=function()&#123;&#125;methods.addMethod(&apos;checkName&apos;,()=&gt;&#123; //验证姓名 return this;&#125;).methods.addMethod(&apos;checkEmail&apos;,()=&gt;&#123; // 验证邮箱&#125;)var check=new method();methods.checkEmail() 封装(使用时再创建)继承(原型链)多态(重载，重写) 第一遍读是7月，后续我没修改。","categories":[],"tags":[{"name":"object","slug":"object","permalink":"http://niuhonggui.github.io/tags/object/"},{"name":"设计模式","slug":"设计模式","permalink":"http://niuhonggui.github.io/tags/设计模式/"}]},{"title":"WebpackReact","slug":"WebpackReact","date":"2018-06-20T03:56:22.000Z","updated":"2019-02-10T06:51:18.640Z","comments":true,"path":"2018/06/20/WebpackReact/","link":"","permalink":"http://niuhonggui.github.io/2018/06/20/WebpackReact/","excerpt":"","text":"本站只提供参考，不保证内容的完整准确性，谨慎参考！ Reacr 前期 webpack 配置注：脚手架搭建的项目首次使用需要配置 git，如果想配置则需要删除隐藏文件 git 相关文件1.初始化 webpacknpm init 2.安装开发依赖npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env @babel/preset-react -D-D 表示开发环境@babel/core @babel/preset-env @babel/preset-react 建议安装最新版的，在 webpack 打包中，会因为版本的冲突报错影响打包，所以建议安装最新版本的 3.安装 react 生产依赖npm install react react-dom -S-S 表示生产环境 4.在当前项目目录下创建 webpack.config.js 写配置文件如果要引入.less的文件 就必须安装相对应依赖 npm i less style-loader css-loader less-loader -D然后在webpack.config.js中写配置 注意：在配置use : [“style-loader”,”css-loader”,”less-loader”] 顺序一定不能变。5.新建一个JS文件 ，测试当前安装的webpack能否完成打包 6.安装webpack热更新(根据项目的代码自动完成打包，就不需要每次写完代码重新webpack一次)npm install webpack-dev-server -D然后在webpack.cong.js写入配置然后进入package.json 加如下代码：这个时候运行npm run start可以访问localhost:8080 记得把index.html文件放到dist文件下，这个时候整个项目就可以运行了","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://niuhonggui.github.io/tags/React/"},{"name":"webpack","slug":"webpack","permalink":"http://niuhonggui.github.io/tags/webpack/"}]},{"title":"hexo+github搭建个人博客","slug":"hexo+github搭建个人博客","date":"2018-05-24T03:11:11.000Z","updated":"2019-02-09T07:06:57.214Z","comments":true,"path":"2018/05/24/hexo+github搭建个人博客/","link":"","permalink":"http://niuhonggui.github.io/2018/05/24/hexo+github搭建个人博客/","excerpt":"","text":"本站只提供参考，不保证内容的完整准确性，不喜勿喷。欢迎来到hexo+github博客搭建教程，这是一篇比较繁琐的blog，本人亲自实战操作经验。 环境配置node环境 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。浏览器打开node官网下载8.11.2版本的msi双击安装 环境测试 win+r打开运行窗口，输入cmd回车 在cmd窗口输入1node -v 如果提示”node不是内部或外部命令”，需要重新安装node如果提示v8.11.2则代表安装成功 git服务 浏览器打开git官网，下载最新版的git安装 安装完毕以后，在桌面右键菜单出现git bash here则代表安装成功 安装hexo脚手架 win+r打开运行窗口，输入cmd回车 在命令行输入1npm install hexo-cli -g 通过npm包管理器全局安装hexo脚手架 博客搭建初始化博客项目 桌面右键选择git bash here 在命令行窗口输入1hexo init blog 通过hexo在桌面新建一个叫blog的博客项目ps:blog是项目名称，名字随意，但不能是中文 切换到blog路径 1cd blog 安装项目依赖 1npm install 启动服务器 1hexo s 预览博客浏览器地址栏输入localhost:4000或者127.0.0.1:4000回车ps：建议使用chrome(谷歌浏览器) hexo常规操作 清理项目缓存1hexo clean 何时使用？修改了博客内容却没有效果或者修复了bug报错依然存在 编译博客1hexo g 何时使用？每次hexo clean之后都需要重新编译部分情况下修改了_config.yml配置文件后需要重新编译手动新建博客文章之后需要重新编译 重启服务器在之前启动服务的命令行窗口使用快捷键”ctrl+c”可以停止hexo服务然后紧接着输入hexo s启动何时使用？修改了_config.yml需要重启服务 hexo项目托管到github本机验证github的key 打开github 注册个人账号并记录下用域名和邮箱，并且验证邮箱 桌面右键打开git bash here 1ssh-keygen -t rsa -C &quot;邮箱&quot; 接下来依次打开：c:/Users/Administrator/.ssh路径找到：id_rsa.pub文件右键选择记事本打开，全选并复制里面的内容(key) 回到github页面，找到头像右侧倒三角下拉菜单，选择settings 在页面左侧选择ssh and gpk 点击右上角绿色 add ssh按钮 在表单输入title(随意)和key(粘贴之前复制到的key)然后点击绿色create ssh按钮 回到刚才创建key的命令行窗口验证用户名和邮箱12git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot; 如果验证成功，没有任何提示。 创建github用户名同名仓库在github页面点击头像左侧的+，选择New repository重点:仓库名必须是:用户名.github.io,严格区分大小写，如：假如用户名为aBc，那么仓库名就为:aBc.github.io 配置hexo找到项目主目录下的_config.yml文件在文档的最下方添加如下内容：1234deploy: type: git repository: http://github.com/用户名/用户名.github.io branch: master 注意：用户名严格区分大小写ps：整个项目有2个_config.yml根目录的_config.yml负责整个项目的一些配置，如：博客名称、语言等themes文件夹内的_config.yml负责主题样式方面的配置 项目推送（这是重点） 安装gcmw（解压压缩包，双击install.cmd） 打开博客项目根目录，右键git bash here 安装deployer-git依赖 1npm install hexo-deployer-git --save 依次执行如下命令 1hexo clean 重新编译1hexo g 推送1hexo d 中途会弹出github的验证，输入相应的应户名密码就好 如果推送成功，在浏览器打开http://用户名.github.io即可访问 #主题更换设置 在github主题库或者问候度娘，找到喜欢的主题然后复制下载命令 安装依赖：npm install hexo 。。。。（此处点点是每个主题不一样命令不同） 在blog文件的主题目录下找到_config.yml 中的theme改为主题名称 重启服务——预览 #留言版功能：本人用的valine","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://niuhonggui.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"http://niuhonggui.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://niuhonggui.github.io/tags/github/"}]},{"title":"置顶","slug":"置顶","date":"2018-04-09T14:56:02.000Z","updated":"2019-02-10T09:40:48.253Z","comments":true,"path":"2018/04/09/置顶/","link":"","permalink":"http://niuhonggui.github.io/2018/04/09/置顶/","excerpt":"","text":"前端里程碑谢谢github,好好利用,定个小任务每月一次跟新技术概况，记录每个月自己技术的成长，今天天气晴，地点：酒泉。","categories":[],"tags":[{"name":"-diary","slug":"diary","permalink":"http://niuhonggui.github.io/tags/diary/"}]}]}